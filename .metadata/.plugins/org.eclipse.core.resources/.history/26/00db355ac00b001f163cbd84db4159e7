/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.validation;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.cNL.DeclVarInput;
import org.xtext.example.cNL.DeclVarOutput;
import org.xtext.example.cNL.Expression;
import org.xtext.example.cNL.Model;
import org.xtext.example.cNL.PrimaryExpression;
import org.xtext.example.cNL.ReqDeclaration;
import org.xtext.example.cNL.SentDeclaration;
import org.xtext.example.cNL.Sentence;
import org.xtext.example.cNL.SentenceDeclaration;
import org.xtext.example.cNL.VarDeclaration;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class CNLValidator extends AbstractCNLValidator {
	
	// Имена переменных не совпадают
    @Check
    public void checkUniqueVariableNames(Model model) {
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                
                for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
                    for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                        if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                            error("Повторяется переменная '" + varName + "' в VAR_INPUT и VAR_OUTPUT", varDecl, null, -1);
                        }
                    }
                }
            }
        }
        
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarInput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_INPUT", varDecl, null, -1);
                    }
                }
            }
        }
        
        for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
            for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_OUTPUT", varDecl, null, -1);
                    }
                }
            }
        }
    }
    
    // Идентификаторы требований не совпадают
    @Check
    public void checkUniqueRequirementNames(Model model) {
        Set<String> requirementNames = new HashSet<>();
    	for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            String reqName = reqDeclaration.getName();
            if (!requirementNames.add(reqName)) {
                error("Повторяется идентификатор требования '" + reqName + "'", reqDeclaration, null, -1);
            }
        }
    }  
    
    // Идентификаторы предложений не совпадают
    @Check
    public void checkUniqueSentenceNames(Model model) {
        Set<String> sentenceNames = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            String sentName = sentDeclaration.getName();
            if (!sentenceNames.add(sentName)) {
                error("Повторяется идентификатор предложения '" + sentName + "'", sentDeclaration, null, -1);
            }
        }
    }
    
    // Строки сначала объявлены, потом использованы в требованиях
    @Check
    public void checkSentencesUsedInTrigger(Model model) {
        Set<String> declaredSentenceNames = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            SentenceDeclaration sentenceDeclaration = sentDeclaration.getSentenceDeclaration();
            Sentence sentenceName = sentenceDeclaration.getName();
            declaredSentenceNames.add(sentenceName.getName());
        }

        for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            if (reqDeclaration.getRequirement().getTrigger().getTrig() != null) {
                Sentence sentence = reqDeclaration.getRequirement().getTrigger().getTrig();
                Sentence sentenceName = sentence;
                if (!declaredSentenceNames.contains(sentenceName.getName())) {
                    error("Trigger не объявлен: " + sentenceName.getName() + "'", reqDeclaration, null, -1);
                }
            }
        }
    }
    
    @Check
    public void checkSentencesUsedInInvariant(Model model) {
        Set<String> declaredSentenceNames = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            SentenceDeclaration sentenceDeclaration = sentDeclaration.getSentenceDeclaration();
            Sentence sentenceName = sentenceDeclaration.getName();
            declaredSentenceNames.add(sentenceName.getName());
        }
        
        for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            if (reqDeclaration.getRequirement().getInvariant().getInv() != null) {
                Sentence sentence = reqDeclaration.getRequirement().getInvariant().getInv();
                Sentence sentenceName = sentence;
                if (!declaredSentenceNames.contains(sentenceName.getName())) {
                    error("Invariant не объявлен: " + sentenceName.getName() + "'", reqDeclaration, null, -1);
                }
            }
            
            else if (reqDeclaration.getRequirement().getTrigger().getInvariant().getInv() != null) {
                Sentence sentence = reqDeclaration.getRequirement().getTrigger().getInvariant().getInv();
                Sentence sentenceName = sentence;
                if (!declaredSentenceNames.contains(sentenceName.getName())) {
                    error("Invariant не объявлен: " + sentenceName.getName() + "'", reqDeclaration, null, -1);
                }
            }
        }
    }
    
     
    // Переменные сначала объявлены, потом использованы в логическом выражении
    @Check
    public void checkDeclaredVariablesInSentDeclaration(SentDeclaration sentDeclaration) {
        Model model = (Model) sentDeclaration.eContainer().eContainer();
        
        // Collect all declared variables from DeclVarInput and DeclVarOutput
        Set<String> declaredVariables = collectDeclaredVariables(model);
        
        // Collect variables used in the logicExpression
        Set<String> usedVariables = collectUsedVariables(sentDeclaration.getSentenceDeclaration().getLogicExpression());
        
        // Check for variables in logicExpression not declared in DeclVarInput or DeclVarOutput
        for (String usedVariable : usedVariables) {
            if (!declaredVariables.contains(usedVariable)) {
                error("Variable '" + usedVariable + "' is not declared in DeclVarInput or DeclVarOutput.", 
                      sentDeclaration, 
                      null, 
                      -1);
            }
        }
    }

    private Set<String> collectDeclaredVariables(Model model) {
        Set<String> declaredVariables = new HashSet<>();
        
        // Collect variables from DeclVarInput
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                declaredVariables.add(varDecl.getName());
            }
        }
        
        // Collect variables from DeclVarOutput
        for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
            for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
                declaredVariables.add(varDecl.getName());
            }
        }
        
        return declaredVariables;
    }

    private Set<String> collectUsedVariables(Expression expression) {
        Set<String> usedVariables = new HashSet<>();
        
        traverseExpression(expression, usedVariables);
        
        return usedVariables;
    }

    private void traverseExpression(EObject eObject, Set<String> usedVariables) {
        if (eObject instanceof PrimaryExpression) {
            PrimaryExpression primary = (PrimaryExpression) eObject;
            if (primary.getVar() != null) { // If this is a variable reference
                usedVariables.add(primary.getV());
            }
        }

        for (EObject child : eObject.eContents()) {
            traverseExpression(child, usedVariables); // Recursively traverse sub-expressions
        }
    }

	// В логических выражениях переменные одного типа
    
    
    // Объявлено (предложение, переменная), но не используется - через warning
    

}

