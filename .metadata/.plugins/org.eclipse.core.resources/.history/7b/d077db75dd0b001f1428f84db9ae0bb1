/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.validation;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.xtext.validation.Check;
import org.xtext.example.cNL.CNLPackage;
import org.xtext.example.cNL.DeclVarInput;
import org.xtext.example.cNL.DeclVarOutput;
import org.xtext.example.cNL.Expression;
import org.xtext.example.cNL.Model;
import org.xtext.example.cNL.PrimaryExpression;
import org.xtext.example.cNL.Rel;
import org.xtext.example.cNL.ReqDeclaration;
import org.xtext.example.cNL.Requirement;
import org.xtext.example.cNL.SentDeclaration;
import org.xtext.example.cNL.SentenceDeclaration;
import org.xtext.example.cNL.Trig;
import org.xtext.example.cNL.VarDeclaration;


/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * @param <VariableType>
 */
public class CNLValidator<VariableType> extends AbstractCNLValidator {
	
	// Имена переменных не совпадают
    @Check
    public void checkUniqueVariableNames(Model model) {
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                
                for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
                    for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                        if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                            error("Повторяется переменная '" + varName + "' в VAR_INPUT и VAR_OUTPUT", varDecl, null, -1);
                        }
                    }
                }
            }
        }
        
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarInput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_INPUT", varDecl, null, -1);
                    }
                }
            }
        }
        
        for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
            for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_OUTPUT", varDecl, null, -1);
                    }
                }
            }
        }
    }
    
    // Идентификаторы требований не совпадают
    @Check
    public void checkUniqueRequirementNames(Model model) {
        Set<String> requirementNames = new HashSet<>();
    	for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            String reqName = reqDeclaration.getName();
            if (!requirementNames.add(reqName)) {
                error("Повторяется идентификатор требования '" + reqName + "'", reqDeclaration, null, -1);
            }
        }
    }  
    
    // Идентификаторы предложений не совпадают
    @Check
    public void checkUniqueSentenceNames(Model model) {
        Set<String> sentenceNames = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            String sentName = sentDeclaration.getDeclarationName();
            if (!sentenceNames.add(sentName)) {
                error("Повторяется идентификатор предложения '" + sentName + "'", sentDeclaration, null, -1);
            }
        }
    }

	// В логических выражениях переменные одного типа
    @Check
    public void checkSameType(Expression expression) {
        Set<VarDeclaration> usedVars = new HashSet<>();
        collectVarDeclarations(expression, usedVars);

        if (usedVars.size() > 1) {
            String expectedType = usedVars.iterator().next().getType();
            for (VarDeclaration var : usedVars) {
                if (!var.getType().equals(expectedType)) {
                    error("Разные типы переменных в логическом выражении. Ожидалось: " + expectedType + 
                    		", но переменная '" + var.getName() + "' имеет тип '" + var.getType() + "'",
                        
                    		CNLPackage.Literals.EXPRESSION__RIGHT,
                    		"inconsistent-types"
                    );
                    return;
                }
            }
        }
    }

    private void collectVarDeclarations(Expression expression, Set<VarDeclaration> usedVars) {
        if (expression.getLeft() != null) {
            collectVarDeclarations(expression.getLeft(), usedVars);
        }
        if (expression.getRight() != null) {
            collectVarDeclarations(expression.getRight(), usedVars);
        } else if (expression instanceof PrimaryExpression) {
            PrimaryExpression primary = (PrimaryExpression) expression;
            if (primary.getName() != null) {
                usedVars.add(primary.getName());
            }
        }
    }
    
    // TODO: Объявлено (предложение, переменная), но не используется - через warning
    @Check
    public void checkForUnusedSentences(Model model) {
        // Step 1: Get all declared sentences
        Set<SentenceDeclaration> declaredSentences = getDeclaredSentences(model);

        // Step 2: Get all referenced sentences from requirements
        Set<SentenceDeclaration> referencedSentences = getReferencedSentences(model);

        // Step 3: Find unused sentences
        Set<SentenceDeclaration> unusedSentences = new HashSet<>(declaredSentences);
        unusedSentences.removeAll(referencedSentences);

        // Step 4: Warn for each unused sentence
        for (SentenceDeclaration unusedSentence : unusedSentences) {
            warning(
                "Sentence '" + unusedSentence.getName() + "' is declared but not used in any requirement.",
                CNLPackage.Literals.SENT_DECLARATION__SENTENCE_DECLARATION
            );
        }
    }

    private Set<SentenceDeclaration> getDeclaredSentences(Model model) {
        Set<SentenceDeclaration> declaredSentences = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            declaredSentences.add(sentDeclaration.getSentenceDeclaration());
        }
        return declaredSentences;
    }

    private Set<SentenceDeclaration> getReferencedSentences(Model model) {
        Set<SentenceDeclaration> referencedSentences = new HashSet<>();
        
        for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            collectReferencedSentences(reqDeclaration.getRequirement(), referencedSentences);
        }

        return referencedSentences;
    }

    private void collectReferencedSentences(Requirement requirement, Set<SentenceDeclaration> referencedSentences) {
        if (requirement == null) {
            return;
        }

        if (requirement.getTrigger() != null) {
            collectTriggerReferences(requirement.getTrigger(), referencedSentences);
        }

        if (requirement.getInvariant() != null) {
            referencedSentences.add(requirement.getInvariant().getInv());
        }

        if (requirement.getInvariant_always() != null) {
            referencedSentences.add(requirement.getInvariant_always().getInv());
        }
    }

    private void collectTriggerReferences(Trig trigger, Set<SentenceDeclaration> referencedSentences) {
        if (trigger.getName() != null) {
            referencedSentences.add(trigger.getName());
        }

        if (trigger.getInvariant() != null) {
            referencedSentences.add(trigger.getInvariant().getInv());
        }

        if (trigger.getRelease_reaction() != null) {
            RelRea relRea = trigger.getRelease_reaction();

            if (relRea instanceof Rel) {
                referencedSentences.add(((Rel) relRea).getRel());
            }

            if (relRea instanceof Rea) {
                Reaction reaction = ((Rea) relRea).getReaction();
                if (reaction != null) {
                    referencedSentences.add(reaction.getRea());
                }
            }
        }

        if (trigger.getDelay_final() != null) {
            SentenceDeclaration delayFin = trigger.getDelay_final().getFin();
            if (delayFin != null) {
                referencedSentences.add(delayFin);
            }
        }
    }
    
}

