/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.validation;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.xtext.validation.Check;
import org.xtext.example.cNL.CNLPackage;
import org.xtext.example.cNL.DeclVarInput;
import org.xtext.example.cNL.DeclVarOutput;
import org.xtext.example.cNL.Expression;
import org.xtext.example.cNL.Model;
import org.xtext.example.cNL.ReqDeclaration;
import org.xtext.example.cNL.SentDeclaration;
import org.xtext.example.cNL.VarDeclaration;
import org.xtext.example.cNL.


/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class CNLValidator extends AbstractCNLValidator {
	
	// Имена переменных не совпадают
    @Check
    public void checkUniqueVariableNames(Model model) {
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                
                for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
                    for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                        if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                            error("Повторяется переменная '" + varName + "' в VAR_INPUT и VAR_OUTPUT", varDecl, null, -1);
                        }
                    }
                }
            }
        }
        
        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarInput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_INPUT", varDecl, null, -1);
                    }
                }
            }
        }
        
        for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
            for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
                String varName = varDecl.getName();
                for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
                    if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
                        error("Повторяется переменная '" + varName + "' в VAR_OUTPUT", varDecl, null, -1);
                    }
                }
            }
        }
    }
    
    // Идентификаторы требований не совпадают
    @Check
    public void checkUniqueRequirementNames(Model model) {
        Set<String> requirementNames = new HashSet<>();
    	for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
            String reqName = reqDeclaration.getName();
            if (!requirementNames.add(reqName)) {
                error("Повторяется идентификатор требования '" + reqName + "'", reqDeclaration, null, -1);
            }
        }
    }  
    
    // Идентификаторы предложений не совпадают
    @Check
    public void checkUniqueSentenceNames(Model model) {
        Set<String> sentenceNames = new HashSet<>();
        for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
            String sentName = sentDeclaration.getDeclarationName();
            if (!sentenceNames.add(sentName)) {
                error("Повторяется идентификатор предложения '" + sentName + "'", sentDeclaration, null, -1);
            }
        }
    }
    
    // Переменные сначала объявлены, потом использованы в логическом выражении
//    @Check
//    public void checkDeclaredVariablesInSentDeclaration(SentDeclaration sentDeclaration) {
//        Model model = (Model) sentDeclaration.eContainer().eContainer();
//        
//        Set<String> declaredVariables = collectDeclaredVariables(model);
//        Set<String> usedVariables = collectUsedVariables(sentDeclaration.getSentenceDeclaration().getLogicExpression());
//        
//        for (String usedVariable : usedVariables) {
//            if (!declaredVariables.contains(usedVariable)) {
//                error("Переменная '" + usedVariable + "'не объявлена в DeclVarInput или DeclVarOutput.", 
//                      sentDeclaration, 
//                      null, 
//                      -1);
//            }
//        }
//    }
//
//    private Set<String> collectDeclaredVariables(Model model) {
//        Set<String> declaredVariables = new HashSet<>();
//        
//        // переменные из DeclVarInput
//        for (DeclVarInput declVarInput : model.getDeclVarInput()) {
//            for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
//                declaredVariables.add(varDecl.getName());
//            }
//        }
//        
//        // переменные из DeclVarOutput
//        for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
//            for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
//                declaredVariables.add(varDecl.getName());
//            }
//        }
//        
//        return declaredVariables;
//    }
//
//    private Set<String> collectUsedVariables(Expression expression) {
//        Set<String> usedVariables = new HashSet<>();
//        
//        traverseExpression(expression, usedVariables);
//        
//        return usedVariables;
//    }
//
//    private void traverseExpression(EObject eObject, Set<String> usedVariables) {
//        if (eObject instanceof PrimaryExpression) {
//            PrimaryExpression primary = (PrimaryExpression) eObject;
//            if (primary.getVar() != null) {
//                usedVariables.add(primary.getVar().toString()); 
//            }
//        }
//
//        for (EObject child : eObject.eContents()) {
//            traverseExpression(child, usedVariables); // рекурсия во вложенные выражения
//        }
//    }

	// В логических выражениях переменные одного типа
    @Check
    public void checkExpressionVarTypes(Expression expression) {
        // Set to collect all referenced variable types in the expression
        Set<VariableType> varTypes = new HashSet<>();

        // Traverse the expression to collect all referenced variable declarations
        collectVariableTypes(expression, varTypes);

        // Check if there is more than one unique variable type in the set
        if (varTypes.size() > 1) {
            error("Variables used in the expression must be of the same type.",
                  CNLPackage.Literals.EXPRESSION__RIGHT);
        }
    }

    private void collectVariableTypes(Expression expression, Set<VariableType> varTypes) {
        if (expression.getLeft() instanceof VarDeclaration) {
            VarDeclaration varDecl = (VarDeclaration) expression.getLeft();
            varTypes.add(varDecl.getType());
        }
        
        if (expression.getRight() instanceof Expression) {
            collectVariableTypes((Expression) expression.getRight(), varTypes);
        } else if (expression.getRight() instanceof VarDeclaration) {
            VarDeclaration varDecl = (VarDeclaration) expression.getRight();
            varTypes.add(varDecl.getType());
        }
    }
    
    // Объявлено (предложение, переменная), но не используется - через warning
//    @Check
//    public void checkForUnusedSentDeclarations(Model model) {
//        Set<SentDeclaration> declaredSentences = new HashSet<>(model.getSentDeclaration());
//        Set<SentDeclaration> usedSentences = new HashSet<>();
//
//        for (ReqDeclaration req : model.getReqDeclaration()) {
//            if (req.getRequirement() instanceof Trig) {
//                Trig trig = (Trig) req.getRequirement();
//                if (trig.getTrig() != null) {
//                    usedSentences.add((SentDeclaration) trig.getTrig());
//                }
//            }
//
//            if (req.getRequirement() instanceof Inv) {
//                Inv inv = (Inv) req.getRequirement();
//                if (inv.getInv() != null) {
//                    usedSentences.add((SentDeclaration) inv.getInv());
//                }
//            }
//
//            // Additional checks for RelRea, DelFin, etc.
//            // E.g., if the req has RelRea and that references a SentDeclaration, add it to usedSentences
//        }
//
//        // Check for unused SentDeclarations
//        for (SentDeclaration declaredSentence : declaredSentences) {
//            if (!usedSentences.contains(declaredSentence)) {
//                warning("This sentence is declared but not used in any requirement.",
//                        CNLPackage.Literals.SENT_DECLARATION__DECLARATION_NAME);
//            }
//        }
//    }

}

