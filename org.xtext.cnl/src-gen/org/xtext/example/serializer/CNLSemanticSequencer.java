/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.cNL.AndExpression;
import org.xtext.example.cNL.CNLPackage;
import org.xtext.example.cNL.CompExpression;
import org.xtext.example.cNL.DeclVarInput;
import org.xtext.example.cNL.DeclVarOutput;
import org.xtext.example.cNL.Del;
import org.xtext.example.cNL.EquExpression;
import org.xtext.example.cNL.Expression;
import org.xtext.example.cNL.Inv;
import org.xtext.example.cNL.Inv_always;
import org.xtext.example.cNL.Model;
import org.xtext.example.cNL.PrimaryExpression;
import org.xtext.example.cNL.Rea;
import org.xtext.example.cNL.Rel;
import org.xtext.example.cNL.ReqDeclaration;
import org.xtext.example.cNL.Requirement;
import org.xtext.example.cNL.SentDeclaration;
import org.xtext.example.cNL.Sentence;
import org.xtext.example.cNL.SentenceDeclaration;
import org.xtext.example.cNL.TauExpression;
import org.xtext.example.cNL.TimeLiteral;
import org.xtext.example.cNL.Trig;
import org.xtext.example.cNL.UnExpression;
import org.xtext.example.cNL.VarDeclaration;
import org.xtext.example.cNL.XorExpression;
import org.xtext.example.services.CNLGrammarAccess;

@SuppressWarnings("all")
public class CNLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CNLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CNLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CNLPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case CNLPackage.COMP_EXPRESSION:
				sequence_CompExpression(context, (CompExpression) semanticObject); 
				return; 
			case CNLPackage.DECL_VAR_INPUT:
				sequence_DeclVarInput(context, (DeclVarInput) semanticObject); 
				return; 
			case CNLPackage.DECL_VAR_OUTPUT:
				sequence_DeclVarOutput(context, (DeclVarOutput) semanticObject); 
				return; 
			case CNLPackage.DEL:
				sequence_Delay(context, (Del) semanticObject); 
				return; 
			case CNLPackage.EQU_EXPRESSION:
				sequence_EquExpression(context, (EquExpression) semanticObject); 
				return; 
			case CNLPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case CNLPackage.INV:
				sequence_Inv(context, (Inv) semanticObject); 
				return; 
			case CNLPackage.INV_ALWAYS:
				sequence_Inv_always(context, (Inv_always) semanticObject); 
				return; 
			case CNLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CNLPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case CNLPackage.REA:
				if (rule == grammarAccess.getReactionRule()) {
					sequence_Reaction(context, (Rea) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelReaRule()) {
					sequence_RelRea(context, (Rea) semanticObject); 
					return; 
				}
				else break;
			case CNLPackage.REL:
				sequence_RelRea(context, (Rel) semanticObject); 
				return; 
			case CNLPackage.REQ_DECLARATION:
				sequence_ReqDeclaration(context, (ReqDeclaration) semanticObject); 
				return; 
			case CNLPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case CNLPackage.SENT_DECLARATION:
				sequence_SentDeclaration(context, (SentDeclaration) semanticObject); 
				return; 
			case CNLPackage.SENTENCE:
				if (rule == grammarAccess.getDelFinRule()) {
					sequence_DelFin(context, (Sentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceRule()) {
					sequence_Sentence(context, (Sentence) semanticObject); 
					return; 
				}
				else break;
			case CNLPackage.SENTENCE_DECLARATION:
				sequence_SentenceDeclaration(context, (SentenceDeclaration) semanticObject); 
				return; 
			case CNLPackage.TAU_EXPRESSION:
				sequence_TauExpression(context, (TauExpression) semanticObject); 
				return; 
			case CNLPackage.TIME_LITERAL:
				sequence_TimeLiteral(context, (TimeLiteral) semanticObject); 
				return; 
			case CNLPackage.TRIG:
				sequence_Trig(context, (Trig) semanticObject); 
				return; 
			case CNLPackage.UN_EXPRESSION:
				sequence_UnExpression(context, (UnExpression) semanticObject); 
				return; 
			case CNLPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			case CNLPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AndExpression
	 *     Expression.Expression_1_0 returns AndExpression
	 *     XorExpression returns AndExpression
	 *     XorExpression.XorExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 andOp=AND_OPERATOR right=CompExpression)
	 * </pre>
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.AND_EXPRESSION__AND_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.AND_EXPRESSION__AND_OP));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndOpAND_OPERATORParserRuleCall_1_1_0(), semanticObject.getAndOp());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightCompExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns CompExpression
	 *     Expression.Expression_1_0 returns CompExpression
	 *     XorExpression returns CompExpression
	 *     XorExpression.XorExpression_1_0 returns CompExpression
	 *     AndExpression returns CompExpression
	 *     AndExpression.AndExpression_1_0 returns CompExpression
	 *     CompExpression returns CompExpression
	 *     CompExpression.CompExpression_1_0 returns CompExpression
	 *
	 * Constraint:
	 *     (left=CompExpression_CompExpression_1_0 compOp=CompOperator right=AndExpression)
	 * </pre>
	 */
	protected void sequence_CompExpression(ISerializationContext context, CompExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.COMP_EXPRESSION__COMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.COMP_EXPRESSION__COMP_OP));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompOpCompOperatorEnumRuleCall_1_1_0(), semanticObject.getCompOp());
		feeder.accept(grammarAccess.getCompExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeclVarInput returns DeclVarInput
	 *
	 * Constraint:
	 *     varDecls+=VarDeclaration+
	 * </pre>
	 */
	protected void sequence_DeclVarInput(ISerializationContext context, DeclVarInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeclVarOutput returns DeclVarOutput
	 *
	 * Constraint:
	 *     varDecls+=VarDeclaration+
	 * </pre>
	 */
	protected void sequence_DeclVarOutput(ISerializationContext context, DeclVarOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DelFin returns Sentence
	 *
	 * Constraint:
	 *     ((delay=Delay fin=Sentence?) | fin=Sentence | fin=Sentence)
	 * </pre>
	 */
	protected void sequence_DelFin(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Delay returns Del
	 *
	 * Constraint:
	 *     del=Sentence
	 * </pre>
	 */
	protected void sequence_Delay(ISerializationContext context, Del semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.DEL__DEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.DEL__DEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelayAccess().getDelSentenceParserRuleCall_2_0(), semanticObject.getDel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns EquExpression
	 *     Expression.Expression_1_0 returns EquExpression
	 *     XorExpression returns EquExpression
	 *     XorExpression.XorExpression_1_0 returns EquExpression
	 *     AndExpression returns EquExpression
	 *     AndExpression.AndExpression_1_0 returns EquExpression
	 *     CompExpression returns EquExpression
	 *     CompExpression.CompExpression_1_0 returns EquExpression
	 *     EquExpression returns EquExpression
	 *     EquExpression.EquExpression_1_0 returns EquExpression
	 *
	 * Constraint:
	 *     (left=EquExpression_EquExpression_1_0 equOp=EquOperator right=UnExpression)
	 * </pre>
	 */
	protected void sequence_EquExpression(ISerializationContext context, EquExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EQU_EXPRESSION__EQU_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EQU_EXPRESSION__EQU_OP));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquOpEquOperatorEnumRuleCall_1_1_0(), semanticObject.getEquOp());
		feeder.accept(grammarAccess.getEquExpressionAccess().getRightUnExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.Expression_1_0 returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 orOp=OR_OPERATOR right=XorExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__OR_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__OR_OP));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getOrOpOR_OPERATORTerminalRuleCall_1_1_0(), semanticObject.getOrOp());
		feeder.accept(grammarAccess.getExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Inv returns Inv
	 *
	 * Constraint:
	 *     (inv=Sentence (delay_final=DelFin | release_reaction=RelRea)?)
	 * </pre>
	 */
	protected void sequence_Inv(ISerializationContext context, Inv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Inv_always returns Inv_always
	 *
	 * Constraint:
	 *     (inv=Sentence release_reaction=RelRea)
	 * </pre>
	 */
	protected void sequence_Inv_always(ISerializationContext context, Inv_always semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.INV_ALWAYS__INV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.INV_ALWAYS__INV));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.INV_ALWAYS__RELEASE_REACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.INV_ALWAYS__RELEASE_REACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInv_alwaysAccess().getInvSentenceParserRuleCall_1_0_0(), semanticObject.getInv());
		feeder.accept(grammarAccess.getInv_alwaysAccess().getRelease_reactionRelReaParserRuleCall_1_6_0(), semanticObject.getRelease_reaction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (declVarInput+=DeclVarInput | declVarOutput+=DeclVarOutput | sentDeclaration+=SentDeclaration | reqDeclaration+=ReqDeclaration)+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PrimaryExpression
	 *     Expression.Expression_1_0 returns PrimaryExpression
	 *     XorExpression returns PrimaryExpression
	 *     XorExpression.XorExpression_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.AndExpression_1_0 returns PrimaryExpression
	 *     CompExpression returns PrimaryExpression
	 *     CompExpression.CompExpression_1_0 returns PrimaryExpression
	 *     EquExpression returns PrimaryExpression
	 *     EquExpression.EquExpression_1_0 returns PrimaryExpression
	 *     UnExpression returns PrimaryExpression
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (constant=Constant | tau=TauExpression | v=ID | nestExpr=Expression)
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Reaction returns Rea
	 *
	 * Constraint:
	 *     rea=Sentence
	 * </pre>
	 */
	protected void sequence_Reaction(ISerializationContext context, Rea semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.REA__REA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.REA__REA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReactionAccess().getReaSentenceParserRuleCall_3_0(), semanticObject.getRea());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelRea returns Rea
	 *
	 * Constraint:
	 *     ((reaction=Reaction delay_final=DelFin?) | (rea=Sentence delay_final=DelFin?))
	 * </pre>
	 */
	protected void sequence_RelRea(ISerializationContext context, Rea semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelRea returns Rel
	 *
	 * Constraint:
	 *     ((rel=Sentence reaction=Reaction delay_final=DelFin?) | rel=Sentence)
	 * </pre>
	 */
	protected void sequence_RelRea(ISerializationContext context, Rel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReqDeclaration returns ReqDeclaration
	 *
	 * Constraint:
	 *     (name=ID requirement=Requirement)
	 * </pre>
	 */
	protected void sequence_ReqDeclaration(ISerializationContext context, ReqDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.REQ_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.REQ_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.REQ_DECLARATION__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.REQ_DECLARATION__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReqDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReqDeclarationAccess().getRequirementRequirementParserRuleCall_2_0(), semanticObject.getRequirement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (trigger=Trig | invariant=Inv_always)
	 * </pre>
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SentDeclaration returns SentDeclaration
	 *
	 * Constraint:
	 *     (name=ID sentenceDeclaration=SentenceDeclaration)
	 * </pre>
	 */
	protected void sequence_SentDeclaration(ISerializationContext context, SentDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.SENT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.SENT_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.SENT_DECLARATION__SENTENCE_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.SENT_DECLARATION__SENTENCE_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSentDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSentDeclarationAccess().getSentenceDeclarationSentenceDeclarationParserRuleCall_3_0(), semanticObject.getSentenceDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SentenceDeclaration returns SentenceDeclaration
	 *
	 * Constraint:
	 *     (name=Sentence logicExpression=Expression)
	 * </pre>
	 */
	protected void sequence_SentenceDeclaration(ISerializationContext context, SentenceDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.SENTENCE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.SENTENCE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.SENTENCE_DECLARATION__LOGIC_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.SENTENCE_DECLARATION__LOGIC_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSentenceDeclarationAccess().getNameSentenceParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSentenceDeclarationAccess().getLogicExpressionExpressionParserRuleCall_3_0(), semanticObject.getLogicExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sentence returns Sentence
	 *
	 * Constraint:
	 *     name=ID_or_INTEGER
	 * </pre>
	 */
	protected void sequence_Sentence(ISerializationContext context, Sentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.SENTENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.SENTENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSentenceAccess().getNameID_or_INTEGERParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TauExpression returns TauExpression
	 *
	 * Constraint:
	 *     time=TimeLiteral
	 * </pre>
	 */
	protected void sequence_TauExpression(ISerializationContext context, TauExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.TAU_EXPRESSION__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.TAU_EXPRESSION__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTauExpressionAccess().getTimeTimeLiteralParserRuleCall_2_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeLiteral returns TimeLiteral
	 *
	 * Constraint:
	 *     interval=INTERVAL
	 * </pre>
	 */
	protected void sequence_TimeLiteral(ISerializationContext context, TimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.TIME_LITERAL__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.TIME_LITERAL__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLiteralAccess().getIntervalINTERVALTerminalRuleCall_1_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trig returns Trig
	 *
	 * Constraint:
	 *     (trig=Sentence? (invariant=Inv | release_reaction=RelRea | delay_final=DelFin))
	 * </pre>
	 */
	protected void sequence_Trig(ISerializationContext context, Trig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns UnExpression
	 *     Expression.Expression_1_0 returns UnExpression
	 *     XorExpression returns UnExpression
	 *     XorExpression.XorExpression_1_0 returns UnExpression
	 *     AndExpression returns UnExpression
	 *     AndExpression.AndExpression_1_0 returns UnExpression
	 *     CompExpression returns UnExpression
	 *     CompExpression.CompExpression_1_0 returns UnExpression
	 *     EquExpression returns UnExpression
	 *     EquExpression.EquExpression_1_0 returns UnExpression
	 *     UnExpression returns UnExpression
	 *
	 * Constraint:
	 *     (unOp=UnOperator right=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_UnExpression(ISerializationContext context, UnExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.UN_EXPRESSION__UN_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.UN_EXPRESSION__UN_OP));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnExpressionAccess().getUnOpUnOperatorParserRuleCall_1_0_0(), semanticObject.getUnOp());
		feeder.accept(grammarAccess.getUnExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (name=ID type=VariableType)
	 * </pre>
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.VAR_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDeclarationAccess().getTypeVariableTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns XorExpression
	 *     Expression.Expression_1_0 returns XorExpression
	 *     XorExpression returns XorExpression
	 *     XorExpression.XorExpression_1_0 returns XorExpression
	 *
	 * Constraint:
	 *     (left=XorExpression_XorExpression_1_0 right=AndExpression)
	 * </pre>
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNLPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
