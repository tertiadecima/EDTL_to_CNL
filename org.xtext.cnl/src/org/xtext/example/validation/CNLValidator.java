/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.validation;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.cNL.*;

import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.pipeline.*;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations;
import edu.stanford.nlp.util.CoreMap;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * @param <VariableType>
 */
public class CNLValidator<VariableType> extends AbstractCNLValidator {

	/* ======================= UNIQUE VAR NAMES ======================= */
	@Check
	public void checkUniqueVariableNames(Model model) {
		for (DeclVarInput declVarInput : model.getDeclVarInput()) {
			for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
				String varName = varDecl.getName();

				for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
					for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
						if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
							error("Повторяется переменная '" + varName + "' в VAR_INPUT и VAR_OUTPUT", varDecl, null, -1);
						}
					}
				}
			}
		}

		for (DeclVarInput declVarInput : model.getDeclVarInput()) {
			for (VarDeclaration varDecl : declVarInput.getVarDecls()) {
				String varName = varDecl.getName();
				for (VarDeclaration otherVarDecl : declVarInput.getVarDecls()) {
					if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
						error("Повторяется переменная '" + varName + "' в VAR_INPUT", varDecl, null, -1);
					}
				}
			}
		}

		for (DeclVarOutput declVarOutput : model.getDeclVarOutput()) {
			for (VarDeclaration varDecl : declVarOutput.getVarDecls()) {
				String varName = varDecl.getName();
				for (VarDeclaration otherVarDecl : declVarOutput.getVarDecls()) {
					if (varDecl != otherVarDecl && varName.equals(otherVarDecl.getName())) {
						error("Повторяется переменная '" + varName + "' в VAR_OUTPUT", varDecl, null, -1);
					}
				}
			}
		}
	}

	/* ======================= UNIQUE SENT NAMES ======================= */
	@Check
	public void checkUniqueSentenceNames(Model model) {
		Set<String> sentenceNames = new HashSet<>();
		for (SentDeclaration sentDeclaration : model.getSentDeclaration()) {
			String sentName = sentDeclaration.getDeclarationName();
			if (!sentenceNames.add(sentName)) {
				error("Повторяется идентификатор предложения '" + sentName + "'", sentDeclaration, null, -1);
			}
		}
	}

	/* ======================= UNIQUE REQ NAMES ======================= */
	@Check
	public void checkUniqueRequirementNames(Model model) {
		Set<String> requirementNames = new HashSet<>();
		for (ReqDeclaration reqDeclaration : model.getReqDeclaration()) {
			String reqName = reqDeclaration.getName();
			if (!requirementNames.add(reqName)) {
				error("Повторяется идентификатор требования '" + reqName + "'", reqDeclaration, null, -1);
			}
		}
	}

	/*
	 * ======================= SAME TYPE IN LOGIC EXPRESSION =======================
	 */
	@Check
	public void checkSameTypeInExpression(Expression expression) {
		Set<VarDeclaration> usedVars = new HashSet<>();
		Set<String> usedElements = new HashSet<>();

		collectVarDeclarationNames(expression, usedVars, usedElements);

		if (usedVars.size() > 1) {
			VarDeclaration expectedVar = usedVars.iterator().next();
			String expectedType = expectedVar.getType();
			for (VarDeclaration var : usedVars) {
				if (!var.getType().equals(expectedType)) {
					error("Разные типы переменных в логическом выражении. Ожидалось: " + expectedType
							+ ", но переменная '" + var.getName() + "' имеет тип '" + var.getType() + "'",

							CNLPackage.Literals.EXPRESSION__RIGHT, "inconsistent-types");
					return;
				}
			}
		}
	}
	
	private void collectVarDeclarationNames(Expression expression, Set<VarDeclaration> usedVars,
			Set<String> usedElements) {
		if (expression.getLeft() != null) {
			collectVarDeclarationNames(expression.getLeft(), usedVars, usedElements);
		}
		if (expression.getRight() != null) {
			collectVarDeclarationNames(expression.getRight(), usedVars, usedElements);
		} else if (expression instanceof PrimaryExpression) {
			PrimaryExpression primary = (PrimaryExpression) expression;
			if (primary.getName() != null) {
				usedVars.add(primary.getName());

				usedElements.add(primary.getName().getName());
			}
			if (primary.getConstant() != null) {
				usedElements.add(primary.getConstant());
			}
		}
	}

	/* ======================= VAR DECLARED AND USED ======================= */
	@Check
	public void checkVariableUsage(VarDeclaration varDecl) {
		Model model = (Model) EcoreUtil2.getContainerOfType(varDecl, Model.class);
		if (!hasCrossReferences(model, varDecl)) {
			warning("Переменная '" + varDecl.getName() + "' объявлена, но не использована",
					CNLPackage.Literals.VAR_DECLARATION__NAME);
		}
	}

	/* ======================= SENT DECLARED AND USED ======================= */
	@Check
	public void checkSentenceUsage(SentenceDeclaration sentDecl) {
		Model model = (Model) EcoreUtil2.getContainerOfType(sentDecl, Model.class);
		if (!hasCrossReferences(model, sentDecl)) {
			warning("Предложение объявлено, но не использовано", CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
		}
	}
	
	private boolean hasCrossReferences(EObject context, EObject target) {
		Set<EObject> targetSet = new HashSet<>();
		targetSet.add(target);
		List<EReference> res = new ArrayList<>();

		EcoreUtil2.ElementReferenceAcceptor acceptor = new EcoreUtil2.ElementReferenceAcceptor() {
			@Override
			public void accept(EObject referrer, EObject referenced, EReference reference, int index) {
				res.add(reference);
			}
		};

		EcoreUtil2.findCrossReferences(context, targetSet, acceptor);
		return !res.isEmpty();
	}
	
	/* ================================================================ */
	/* ======================= STANFORD CORENLP ======================= */
	/* ================================================================ */
	 private static final StanfordCoreNLP pipeline;

	    static {
	        Properties props = new Properties();
	        props.setProperty("annotators", "tokenize,ssplit,pos,lemma,parse");
	        pipeline = new StanfordCoreNLP(props);
	    }
	    
//	    public void parseSentence(SentenceDeclaration sentDecl) { // логирование для проверки
//	        String input = sentDecl.getName().replaceAll("^\"|\"$", "");
//
//	        CoreDocument doc = new CoreDocument(input);
//	        pipeline.annotate(doc);
//
//	        for (CoreSentence sentence : doc.sentences()) {
//	            // текст предложения
//	            System.out.println("Analyzing sentence: " + sentence.text());
//
//	            // токены
//	            List<String> tokens = sentence.tokens().stream()
//	                .map(token -> token.word())
//	                .collect(Collectors.toList());
//	            System.out.println("Tokens: " + tokens);
//
//	            // POS теги
//	            List<String> posTags = sentence.posTags();
//	            System.out.println("POS Tags: " + posTags);
//
//	            // parse tree
//	            Tree parseTree = sentence.constituencyParse();
//	            System.out.println("Parse Tree:\n" + parseTree);
//	        }
//	    }
	    
		 /* ======================= SENTENCE HAS A SUBJ & A PREDICATE ======================= */
	    
	    @Check
	    public void checkSentenceIsGrammaticallyValid(SentenceDeclaration sentenceDecl) {
	        String rawSentence = sentenceDecl.getName();
	        Annotation doc = new Annotation(rawSentence);
	        pipeline.annotate(doc);

	        List<CoreMap> sentences = doc.get(CoreAnnotations.SentencesAnnotation.class);
	        if (sentences == null || sentences.isEmpty()) {
	            error("В предложении содержится грамматическая ошибка", CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	            return;
	        }

	        Tree parseTree = sentences.get(0).get(TreeCoreAnnotations.TreeAnnotation.class);
	        if (!parseTree.toString().contains("NP")) {
	            warning("В предложении отсутствует подлежащее", CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	        }
	        if (!parseTree.toString().contains("VP")) {
	            warning("В предложении отсутствует сказуемое", CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	        }
//	        if (!posTags.contains("VB") && !posTags.contains("VBD") && !posTags.contains("VBP") && !posTags.contains("VBZ")) {
//                warning("Высказывание может быть не завершено (отсутствует глагол).",
//                        CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
//            }
	    }
	    
	 /* ======================= SENTENCE IS IN PRESENT TENSE ======================= */
	    
	    @Check
	    public void checkUsePresentTense(SentenceDeclaration sentenceDecl) {
	        String input = sentenceDecl.getName();
	        CoreDocument doc = new CoreDocument(input);
	        pipeline.annotate(doc);
	        
	        for (CoreSentence sentence : doc.sentences()) {
	            List<String> tokens = sentence.tokens().stream()
	                .map(token -> token.word())
	                .collect(Collectors.toList());
	            
	            List<String> posTags = sentence.posTags();

	            if (tokens.contains("was") || tokens.contains("were") || posTags.contains("VBD")) {
	                warning("Используйте настоящее время в предложениях",
	                        CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	            }
	        }
	    }

		 /* ======================= SENTENCE IS TOO LONG ======================= */

	    @Check
	    public void checkSentenceLength(SentenceDeclaration sentDecl) {
	        String input = sentDecl.getName();

	        CoreDocument doc = new CoreDocument(input);
	        pipeline.annotate(doc);

	        for (CoreSentence sentence : doc.sentences()) {
	            if (sentence.tokens().size() > 10) {
	                warning("Предложение может быть слишком длинным (>10 слов).", 
	                        CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	            }
	        }
	    }
	    
	    /* ======================= NOUN CLUSTERS ======================= */

	    @Check
	    public void checkNounClusterLength(SentenceDeclaration sentDecl) {
	        String input = sentDecl.getName();

	        CoreDocument doc = new CoreDocument(input);
	        pipeline.annotate(doc);

	        for (CoreSentence sentence : doc.sentences()) {
	            List<String> posTags = sentence.posTags();
	            int clusterLength = 0;
	            for (String tag : posTags) {
	                if (tag.matches("NN|NNS|NNP|NNPS")) {
	                    clusterLength++;
	                    if (clusterLength > 2) {
	                        warning("Избегайте скопления существительных.",
	                                CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	                        break;
	                    }
	                } else {
	                    clusterLength = 0; // на не-сущ сброс
	                }
	            }
	        }
	    }
	    
	    /* ======================= PERSONAL PRONOUNS ======================= */

	    @Check
	    public void checkNoPersonalPronouns(SentenceDeclaration sentDecl) {
	        String input = sentDecl.getName();

	        CoreDocument doc = new CoreDocument(input);
	        pipeline.annotate(doc);

	        for (CoreSentence sentence : doc.sentences()) {
	            List<String> posTags = sentence.posTags();
	            List<String> tokens = sentence.tokens().stream().map(CoreLabel::originalText).toList();

	            for (int i = 0; i < posTags.size(); i++) {
	                String pos = posTags.get(i);
	                if ("PRP".equals(pos) || "PRP$".equals(pos)) {
	                    String pronoun = tokens.get(i);
	                    warning("Избегайте личных местоимений в требованиях: \"" + pronoun + "\"",
	                            CNLPackage.Literals.SENTENCE_DECLARATION__NAME);
	                    break;
	                }
	            }
	        }
	    }

}
